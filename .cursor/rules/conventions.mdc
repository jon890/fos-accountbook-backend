---
alwaysApply: true
description: Spring Boot 코딩 컨벤션
tags: [conventions, entity, dto, service, controller]
version: "1.0"
---

# 코딩 컨벤션

## 1. Entity 규칙

```java
@Entity
@Table(name = "user_profiles")  // ✅ snake_case 필수
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserProfile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;  // ✅ PK는 Long auto_increment

    @Column(name = "user_uuid", nullable = false)  // ✅ snake_case
    private CustomUuid userUuid;  // ✅ 관계는 UUID 기반

    @Column(name = "timezone")
    private String timezone;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "deleted_at")  // ✅ Soft Delete
    private LocalDateTime deletedAt;
}
```

**핵심:**
- 테이블명/컬럼명: `snake_case` 필수
- PK: `Long id` (auto_increment)
- 관계: UUID 기반 (`user_uuid`, `family_uuid`)
- Soft Delete: `deleted_at` 컬럼 사용
- Lombok: `@Builder`, `@Getter`, `@NoArgsConstructor`, `@AllArgsConstructor`

---

## 2. Repository 패턴

```java
// Domain Layer - 인터페이스만
public interface UserRepository {
    User save(User user);
    Optional<User> findByUuid(CustomUuid uuid);
}

// Infrastructure Layer - 구현체
@Repository
public class UserJpaRepository implements UserRepository {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public User save(User user) {
        // JPA 구현
    }
}
```

---

## 3. Service 규칙

```java
@Service
@RequiredArgsConstructor  // ✅ Lombok 생성자 주입
@Transactional(readOnly = true)  // ✅ 기본 readOnly
public class UserProfileService {

    private final UserProfileRepository userProfileRepository;

    @Transactional  // ✅ 쓰기 작업만 @Transactional
    public UserProfileResponse updateProfile(CustomUuid userUuid, UpdateRequest request) {
        UserProfile profile = userProfileRepository.findByUserUuid(userUuid)
            .orElseThrow(() -> new IllegalArgumentException("프로필을 찾을 수 없습니다"));

        profile.updateTimezone(request.getTimezone());

        UserProfile saved = userProfileRepository.save(profile);
        return UserProfileResponse.from(saved);
    }
}
```

---

## 4. Controller 규칙

```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserProfileController {

    private final UserProfileService userProfileService;

    @GetMapping("/me/profile")
    public ResponseEntity<ApiSuccessResponse<UserProfileResponse>> getMyProfile(
        @LoginUser LoginUserDto user  // ✅ 커스텀 애노테이션
    ) {
        UserProfileResponse response = userProfileService.getOrCreateProfile(user.getUserUuid());
        return ResponseEntity.ok(
            ApiSuccessResponse.of("프로필을 조회했습니다", response)
        );
    }

    @PutMapping("/me/profile")
    public ResponseEntity<ApiSuccessResponse<UserProfileResponse>> updateMyProfile(
        @LoginUser LoginUserDto user,
        @Valid @RequestBody UpdateUserProfileRequest request  // ✅ @Valid 검증
    ) {
        UserProfileResponse response = userProfileService.updateProfile(user.getUserUuid(), request);
        return ResponseEntity.ok(
            ApiSuccessResponse.of("프로필이 수정되었습니다", response)
        );
    }
}
```

**핵심:**
- RESTful API 설계 (GET, POST, PUT, DELETE)
- `@Valid` 필수 사용
- `@LoginUser` 커스텀 애노테이션으로 인증 처리
- 공통 응답: `ApiSuccessResponse<T>`, `ApiErrorResponse`

---

## 5. DTO 규칙

```java
// Request DTO
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UpdateUserProfileRequest {

    @Pattern(regexp = "^[A-Za-z/_]+$", message = "올바른 시간대 형식이 아닙니다")
    private String timezone;

    @Pattern(regexp = "^[a-z]{2}$", message = "언어 코드는 2자리여야 합니다")
    private String language;
}

// Response DTO
@Getter
@Builder
public class UserProfileResponse {
    private String userUuid;
    private String timezone;
    private String language;

    public static UserProfileResponse from(UserProfile profile) {
        return UserProfileResponse.builder()
            .userUuid(profile.getUserUuid().getValue())
            .timezone(profile.getTimezone())
            .language(profile.getLanguage())
            .build();
    }
}
```

**핵심:**
- ❌ `@Data` 사용 금지
- ✅ `@Getter` + `@Builder` + `@NoArgsConstructor` + `@AllArgsConstructor`
- ✅ Setter 없이 불변 객체로 관리
- ✅ `from()` 정적 팩토리 메서드로 변환

---

## ⚠️ 주의사항

### 절대 금지 ❌

1. **풀패키지 경로 사용 금지**
   ```java
   // ❌ 나쁨
   org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration.class

   // ✅ 좋음
   import org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration;
   UserDetailsServiceAutoConfiguration.class
   ```

2. **@Data 사용 금지**
   - DTO는 불변 객체로 관리
   - Setter 제공하지 않음

3. **Service/Repository 모킹 금지**
   - 외부 API만 모킹
   - 내부 컴포넌트는 실제 빈 사용
