---
alwaysApply: true
description: Spring Boot 코딩 컨벤션
tags: [conventions, entity, dto, service, controller]
version: "1.0"
---

# 코딩 컨벤션

## 1. Entity 규칙

```java
@Entity
@Table(name = "user_profiles")  // ✅ snake_case 필수
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserProfile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;  // ✅ PK는 Long auto_increment

    @Column(name = "user_uuid", nullable = false)  // ✅ snake_case
    private CustomUuid userUuid;  // ✅ 관계는 UUID 기반

    @Column(name = "timezone")
    private String timezone;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "deleted_at")  // ✅ Soft Delete
    private LocalDateTime deletedAt;
}
```

**핵심:**
- 테이블명/컬럼명: `snake_case` 필수
- PK: `Long id` (auto_increment)
- 관계: UUID 기반 (`user_uuid`, `family_uuid`)
- Soft Delete: `deleted_at` 컬럼 사용
- Lombok: `@Builder`, `@Getter`, `@NoArgsConstructor`, `@AllArgsConstructor`

---

## 2. Repository 패턴

```java
// Domain Layer - 인터페이스만
public interface UserRepository {
    User save(User user);
    Optional<User> findByUuid(CustomUuid uuid);
}

// Infrastructure Layer - 구현체
@Repository
public class UserJpaRepository implements UserRepository {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public User save(User user) {
        // JPA 구현
    }
}
```

---

## 3. Service 규칙

```java
@Service
@RequiredArgsConstructor  // ✅ Lombok 생성자 주입
@Transactional(readOnly = true)  // ✅ 기본 readOnly
public class UserProfileService {

    private final UserProfileRepository userProfileRepository;

    @Transactional  // ✅ 쓰기 작업만 @Transactional
    public UserProfileResponse updateProfile(CustomUuid userUuid, UpdateRequest request) {
        UserProfile profile = userProfileRepository.findByUserUuid(userUuid)
            .orElseThrow(() -> new IllegalArgumentException("프로필을 찾을 수 없습니다"));

        profile.updateTimezone(request.getTimezone());

        UserProfile saved = userProfileRepository.save(profile);
        return UserProfileResponse.from(saved);
    }
}
```

---

## 4. Controller 규칙

```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserProfileController {

    private final UserProfileService userProfileService;

    @GetMapping("/me/profile")
    public ResponseEntity<ApiSuccessResponse<UserProfileResponse>> getMyProfile(
        @LoginUser LoginUserDto user  // ✅ 커스텀 애노테이션
    ) {
        UserProfileResponse response = userProfileService.getOrCreateProfile(user.getUserUuid());
        return ResponseEntity.ok(
            ApiSuccessResponse.of("프로필을 조회했습니다", response)
        );
    }

    @PutMapping("/me/profile")
    public ResponseEntity<ApiSuccessResponse<UserProfileResponse>> updateMyProfile(
        @LoginUser LoginUserDto user,
        @Valid @RequestBody UpdateUserProfileRequest request  // ✅ @Valid 검증
    ) {
        UserProfileResponse response = userProfileService.updateProfile(user.getUserUuid(), request);
        return ResponseEntity.ok(
            ApiSuccessResponse.of("프로필이 수정되었습니다", response)
        );
    }
}
```

**핵심:**
- RESTful API 설계 (GET, POST, PUT, DELETE)
- `@Valid` 필수 사용
- `@LoginUser` 커스텀 애노테이션으로 인증 처리
- 공통 응답: `ApiSuccessResponse<T>`, `ApiErrorResponse`

---

## 5. DTO 규칙

```java
// Request DTO
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UpdateUserProfileRequest {

    @Pattern(regexp = "^[A-Za-z/_]+$", message = "올바른 시간대 형식이 아닙니다")
    private String timezone;

    @Pattern(regexp = "^[a-z]{2}$", message = "언어 코드는 2자리여야 합니다")
    private String language;
}

// Response DTO
@Getter
@Builder
public class UserProfileResponse {
    private String userUuid;
    private String timezone;
    private String language;

    public static UserProfileResponse from(UserProfile profile) {
        return UserProfileResponse.builder()
            .userUuid(profile.getUserUuid().getValue())
            .timezone(profile.getTimezone())
            .language(profile.getLanguage())
            .build();
    }
}
```

**핵심:**
- ❌ `@Data` 사용 금지
- ✅ `@Getter` + `@Builder` + `@NoArgsConstructor` + `@AllArgsConstructor`
- ✅ Setter 없이 불변 객체로 관리
- ✅ `from()` 정적 팩토리 메서드로 변환

---

## ⚠️ 주의사항

### 절대 금지 ❌

1. **풀패키지 경로 사용 금지**
   ```java
   // ❌ 나쁨
   org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration.class

   // ✅ 좋음
   import org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration;
   UserDetailsServiceAutoConfiguration.class
   ```

2. **@Data 사용 금지**
   - DTO는 불변 객체로 관리
   - Setter 제공하지 않음

3. **Service/Repository 모킹 금지**
   - 외부 API만 모킹
   - 내부 컴포넌트는 실제 빈 사용

---

## 6. 코드 스타일 (Google Java Style + Naver Convention)

> 참고: [네이버 핵데이 Java 코딩 컨벤션](https://naver.github.io/hackday-conventions-java/)

### 들여쓰기
- **기본 들여쓰기**: 2 spaces
- **연속 들여쓰기(Continuation Indent)**: 4 spaces
- **최대 줄 길이**: 150자

```java
// ✅ 긴 파라미터
public void someMethod(
    String firstParameter,
    String secondParameter,
    String thirdParameter) {
  // 메서드 본문 (2 spaces)
}
```

### 중괄호 (K&R 스타일)
- 모든 제어문(if, for, while)에서 중괄호 필수
- 여는 중괄호 `{`는 선언문과 같은 줄에
- 닫는 중괄호 `}`는 새로운 줄에
- `else`, `catch`, `finally`, `while`은 닫는 중괄호와 같은 줄에

```java
// ✅ 올바른 예시
if (condition) {
  doSomething();
} else {
  doOtherThing();
}

try {
  process();
} catch (Exception e) {
  handleError(e);
} finally {
  cleanup();
}

// ❌ 잘못된 예시
if (condition)
  doSomething();  // 중괄호 없음
```

### 메서드 체이닝
- **`.`은 앞 줄의 끝에 위치**
- 연속 들여쓰기 4 spaces 적용

```java
// ✅ 올바른 예시
var opt = Optional.ofNullable(value).
    map(v -> v.toString()).
    orElseThrow();

User user = userRepository.
    findByEmail(email).
    orElseThrow(() -> new UserNotFoundException());

List<Integer> result = list.stream().
    filter(x -> x > 0).
    map(x -> x * 2).
    collect(Collectors.toList());
```

### 이름 규칙 (Naming Convention)

#### 식별자 규칙
- 영문, 숫자, 언더스코어만 허용
- ❌ **한국어 발음 표기 금지**
  ```java
  // ❌ 나쁨
  String jibun;
  int danwi;
  
  // ✅ 좋음
  String address;
  int unit;
  ```

#### 대문자 약어 명시
- 2글자 약어: 모두 대문자 (예: `IO`, `UI`)
- 3글자 이상: 첫 글자만 대문자 (예: `Xml`, `Json`, `Html`)

```java
// ✅ 올바른 예시
IOUtils
parseXml()
convertJsonToMap()

// ❌ 잘못된 예시
IoUtils
parseXML()
convertJSONToMap()
```

#### 상수 명명 규칙
- 대문자와 언더스코어로 구성
- `static final`로 선언된 불변 객체

```java
public static final int MAX_SIZE = 100;
public static final String DEFAULT_NAME = "Unknown";
```

### 선언 규칙 (Declarations)

#### 제한자 순서
```java
// ✅ 올바른 순서
public static final synchronized void method() { }
private static final String CONSTANT = "value";
```

**순서**: public → protected → private → abstract → static → final → transient → volatile → synchronized → native → strictfp

#### 애너테이션 선언
- 애너테이션은 선언 후 새줄 사용
- 파라미터 없는 애너테이션은 같은 줄에 나열 가능

```java
// ✅ 올바른 예시
@Override
@Deprecated
public void method() { }

@Getter @Setter @ToString
public class User { }

// ❌ 잘못된 예시
@Override @Deprecated public void method() { }  // 파라미터 있는 애너테이션 같은 줄
```

#### import 규칙
- static import에만 와일드카드(`*`) 허용
- 일반 import는 개별 클래스 명시

```java
// ✅ 올바른 예시
import static org.junit.jupiter.api.Assertions.*;
import java.util.List;
import java.util.ArrayList;

// ❌ 잘못된 예시
import java.util.*;  // 일반 import에 와일드카드
```

### 공백 규칙 (Whitespace)

#### 제어문 키워드
```java
// ✅ 키워드와 여는 소괄호 사이 공백
if (condition) { }
for (int i = 0; i < 10; i++) { }
while (running) { }
```

#### 연산자
```java
// ✅ 이항/삼항 연산자 앞뒤 공백
int sum = a + b;
String result = (x > 0) ? "positive" : "negative";

// ✅ 단항 연산자는 공백 없음
i++;
!flag;
```

#### 괄호
```java
// ✅ 메서드 선언/호출 시 식별자와 여는 소괄호 사이 공백 없음
public void method(int param) { }
method(10);

// ✅ 타입 캐스팅 소괄호 내부 공백 없음
String s = (String)object;
```

### 빈 줄 (Blank Lines)

```java
// ✅ 올바른 예시
package com.example;

import java.util.List;  // package 후 빈 줄

import org.springframework.stereotype.Service;  // import 그룹 사이 빈 줄

public class MyService {
  
  public void method1() {
    // 구현
  }
  
  public void method2() {  // 메서드 사이 빈 줄
    // 구현
  }
}
```

### Checkstyle
- Google Java Style 기반 Checkstyle 적용
- 빌드 시 자동 검사
- 위치: `config/checkstyle/google_checks.xml`
- 실행: `./gradlew checkstyleMain`

---

## 7. IntelliJ IDEA 설정

### 메서드 체이닝 스타일 설정

메서드 체이닝에서 `.`이 앞 줄 끝에 오도록 설정:

1. `File > Settings > Editor > Code Style > Java` (Mac: `Preferences > Editor > Code Style > Java`)
2. `Wrapping and Braces` 탭 선택
3. `Chained method calls` 항목 찾기
4. 다음과 같이 설정:
   - **Wrap if long**: 선택
   - **Wrap first call**: 선택 해제
   - **Align when multiline**: 선택 해제
   - **Take '.' on new line**: **선택 해제** ⚠️ 중요!

또는 XML 설정:

`File > Settings > Editor > Code Style > Java > ⚙️ > Export > IntelliJ IDEA code style XML`

```xml
<code_scheme name="Project" version="173">
  <JavaCodeStyleSettings>
    <option name="METHOD_CALL_CHAIN_WRAP" value="5" />
  </JavaCodeStyleSettings>
  <codeStyleSettings language="JAVA">
    <option name="METHOD_CALL_CHAIN_WRAP" value="5" />
    <option name="WRAP_FIRST_METHOD_IN_CALL_CHAIN" value="false" />
  </codeStyleSettings>
</code_scheme>
```

### 적용 방법

1. **수동 포맷팅**: `Cmd + Option + L` (Mac) / `Ctrl + Alt + L` (Windows/Linux)
2. **자동 포맷팅**: `File > Settings > Tools > Actions on Save` → `Reformat code` 선택

### 결과 예시

```java
// ✅ 설정 후 포맷팅 결과
Category transportCategory = categories.stream().
    filter(c -> "교통비".equals(c.getName())).
    findFirst().
    orElse(null);
```
