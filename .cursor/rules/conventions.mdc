---
alwaysApply: true
description: Spring Boot 코딩 컨벤션
tags: [conventions, entity, dto, service, controller]
version: "1.0"
---

# 코딩 컨벤션

## 1. Entity 규칙

```java
@Entity
@Table(name = "user_profiles")  // ✅ snake_case 필수
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserProfile {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;  // ✅ PK는 Long auto_increment

    @Column(name = "user_uuid", nullable = false)  // ✅ snake_case
    private CustomUuid userUuid;  // ✅ 관계는 UUID 기반

    @Column(name = "timezone")
    private String timezone;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "deleted_at")  // ✅ Soft Delete
    private LocalDateTime deletedAt;
}
```

**핵심:**
- 테이블명/컬럼명: `snake_case` 필수
- PK: `Long id` (auto_increment)
- 관계: UUID 기반 (`user_uuid`, `family_uuid`)
- Soft Delete: `deleted_at` 컬럼 사용
- Lombok: `@Builder`, `@Getter`, `@NoArgsConstructor`, `@AllArgsConstructor`

---

## 2. Repository 패턴

```java
// Domain Layer - 인터페이스만
public interface UserRepository {
    User save(User user);
    Optional<User> findByUuid(CustomUuid uuid);
}

// Infrastructure Layer - 구현체
@Repository
public class UserJpaRepository implements UserRepository {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public User save(User user) {
        // JPA 구현
    }
}
```

---

## 3. Service 규칙

```java
@Service
@RequiredArgsConstructor  // ✅ Lombok 생성자 주입
@Transactional(readOnly = true)  // ✅ 기본 readOnly
public class UserProfileService {

    private final UserProfileRepository userProfileRepository;

    @Transactional  // ✅ 쓰기 작업만 @Transactional
    public UserProfileResponse updateProfile(CustomUuid userUuid, UpdateRequest request) {
        UserProfile profile = userProfileRepository.findByUserUuid(userUuid)
            .orElseThrow(() -> new IllegalArgumentException("프로필을 찾을 수 없습니다"));

        profile.updateTimezone(request.getTimezone());

        UserProfile saved = userProfileRepository.save(profile);
        return UserProfileResponse.from(saved);
    }
}
```

---

## 4. Controller 규칙

```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserProfileController {

    private final UserProfileService userProfileService;

    @GetMapping("/me/profile")
    public ResponseEntity<ApiSuccessResponse<UserProfileResponse>> getMyProfile(
        @LoginUser LoginUserDto user  // ✅ 커스텀 애노테이션
    ) {
        UserProfileResponse response = userProfileService.getOrCreateProfile(user.getUserUuid());
        return ResponseEntity.ok(
            ApiSuccessResponse.of("프로필을 조회했습니다", response)
        );
    }

    @PutMapping("/me/profile")
    public ResponseEntity<ApiSuccessResponse<UserProfileResponse>> updateMyProfile(
        @LoginUser LoginUserDto user,
        @Valid @RequestBody UpdateUserProfileRequest request  // ✅ @Valid 검증
    ) {
        UserProfileResponse response = userProfileService.updateProfile(user.getUserUuid(), request);
        return ResponseEntity.ok(
            ApiSuccessResponse.of("프로필이 수정되었습니다", response)
        );
    }
}
```

**핵심:**
- RESTful API 설계 (GET, POST, PUT, DELETE)
- `@Valid` 필수 사용
- `@LoginUser` 커스텀 애노테이션으로 인증 처리
- 공통 응답: `ApiSuccessResponse<T>`, `ApiErrorResponse`

---

## 5. DTO 규칙

```java
// Request DTO
@Getter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UpdateUserProfileRequest {

    @Pattern(regexp = "^[A-Za-z/_]+$", message = "올바른 시간대 형식이 아닙니다")
    private String timezone;

    @Pattern(regexp = "^[a-z]{2}$", message = "언어 코드는 2자리여야 합니다")
    private String language;
}

// Response DTO
@Getter
@Builder
public class UserProfileResponse {
    private String userUuid;
    private String timezone;
    private String language;

    public static UserProfileResponse from(UserProfile profile) {
        return UserProfileResponse.builder()
            .userUuid(profile.getUserUuid().getValue())
            .timezone(profile.getTimezone())
            .language(profile.getLanguage())
            .build();
    }
}
```

**핵심:**
- ❌ `@Data` 사용 금지
- ✅ `@Getter` + `@Builder` + `@NoArgsConstructor` + `@AllArgsConstructor`
- ✅ Setter 없이 불변 객체로 관리
- ✅ `from()` 정적 팩토리 메서드로 변환

---

## ⚠️ 주의사항

### 절대 금지 ❌

1. **풀패키지 경로 사용 금지**
   ```java
   // ❌ 나쁨
   org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration.class

   // ✅ 좋음
   import org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration;
   UserDetailsServiceAutoConfiguration.class
   ```

2. **@Data 사용 금지**
   - DTO는 불변 객체로 관리
   - Setter 제공하지 않음

3. **Service/Repository 모킹 금지**
   - 외부 API만 모킹
   - 내부 컴포넌트는 실제 빈 사용

---

## 6. 코드 스타일 (Google Java Style + Naver Convention)

> 참고: [네이버 핵데이 Java 코딩 컨벤션](https://naver.github.io/hackday-conventions-java/)

### 들여쓰기
- **기본 들여쓰기**: 2 spaces
- **연속 들여쓰기(Continuation Indent)**: 4 spaces
- **최대 줄 길이**: 150자

```java
// ✅ 긴 파라미터
public void someMethod(
    String firstParameter,
    String secondParameter,
    String thirdParameter) {
  // 메서드 본문 (2 spaces)
}
```

### 중괄호 (K&R 스타일)
- 모든 제어문(if, for, while)에서 중괄호 필수
- 여는 중괄호 `{`는 선언문과 같은 줄에
- 닫는 중괄호 `}`는 새로운 줄에
- `else`, `catch`, `finally`, `while`은 닫는 중괄호와 같은 줄에

```java
// ✅ 올바른 예시
if (condition) {
  doSomething();
} else {
  doOtherThing();
}

try {
  process();
} catch (Exception e) {
  handleError(e);
} finally {
  cleanup();
}

// ❌ 잘못된 예시
if (condition)
  doSomething();  // 중괄호 없음
```

### 메서드 체이닝
- **`.`은 새 줄의 시작 부분에 위치**
- 연속 들여쓰기 4 spaces 적용
- `ij_java_binary_operation_sign_on_next_line = true` 설정

```java
// ✅ 올바른 예시
var opt = Optional.ofNullable(value)
    .map(v -> v.toString())
    .orElseThrow();

User user = userRepository
    .findByEmail(email)
    .orElseThrow(() -> new UserNotFoundException());

List<Integer> result = list.stream()
    .filter(x -> x > 0)
    .map(x -> x * 2)
    .collect(Collectors.toList());

Category transportCategory = categories.stream()
    .filter(c -> "교통비".equals(c.getName()))
    .findFirst()
    .orElse(null);
```

### 이름 규칙 (Naming Convention)

#### 식별자 규칙
- 영문, 숫자, 언더스코어만 허용
- ❌ **한국어 발음 표기 금지**
  ```java
  // ❌ 나쁨
  String jibun;
  int danwi;
  
  // ✅ 좋음
  String address;
  int unit;
  ```

#### 대문자 약어 명시
- 2글자 약어: 모두 대문자 (예: `IO`, `UI`)
- 3글자 이상: 첫 글자만 대문자 (예: `Xml`, `Json`, `Html`)

```java
// ✅ 올바른 예시
IOUtils
parseXml()
convertJsonToMap()

// ❌ 잘못된 예시
IoUtils
parseXML()
convertJSONToMap()
```

#### 상수 명명 규칙
- 대문자와 언더스코어로 구성
- `static final`로 선언된 불변 객체

```java
public static final int MAX_SIZE = 100;
public static final String DEFAULT_NAME = "Unknown";
```

### 선언 규칙 (Declarations)

#### 제한자 순서
```java
// ✅ 올바른 순서
public static final synchronized void method() { }
private static final String CONSTANT = "value";
```

**순서**: public → protected → private → abstract → static → final → transient → volatile → synchronized → native → strictfp

#### 애너테이션 선언
- 애너테이션은 선언 후 새줄 사용
- 파라미터 없는 애너테이션은 같은 줄에 나열 가능

```java
// ✅ 올바른 예시
@Override
@Deprecated
public void method() { }

@Getter @Setter @ToString
public class User { }

// ❌ 잘못된 예시
@Override @Deprecated public void method() { }  // 파라미터 있는 애너테이션 같은 줄
```

#### import 규칙
- static import에만 와일드카드(`*`) 허용
- 일반 import는 개별 클래스 명시

```java
// ✅ 올바른 예시
import static org.junit.jupiter.api.Assertions.*;
import java.util.List;
import java.util.ArrayList;

// ❌ 잘못된 예시
import java.util.*;  // 일반 import에 와일드카드
```

### 공백 규칙 (Whitespace)

#### 제어문 키워드
```java
// ✅ 키워드와 여는 소괄호 사이 공백
if (condition) { }
for (int i = 0; i < 10; i++) { }
while (running) { }
```

#### 연산자
```java
// ✅ 이항/삼항 연산자 앞뒤 공백
int sum = a + b;
String result = (x > 0) ? "positive" : "negative";

// ✅ 단항 연산자는 공백 없음
i++;
!flag;
```

#### 괄호
```java
// ✅ 메서드 선언/호출 시 식별자와 여는 소괄호 사이 공백 없음
public void method(int param) { }
method(10);

// ✅ 타입 캐스팅 소괄호 내부 공백 없음
String s = (String)object;
```

### 빈 줄 (Blank Lines)

```java
// ✅ 올바른 예시
package com.example;

import java.util.List;  // package 후 빈 줄

import org.springframework.stereotype.Service;  // import 그룹 사이 빈 줄

public class MyService {
  
  public void method1() {
    // 구현
  }
  
  public void method2() {  // 메서드 사이 빈 줄
    // 구현
  }
}
```

### Checkstyle
- Google Java Style 기반 Checkstyle 적용
- 빌드 시 자동 검사
- 위치: `config/checkstyle/google_checks.xml`
- 실행: `./gradlew checkstyleMain`

---

## 7. IDE 설정 (IntelliJ & Cursor 통합)

프로젝트는 **IntelliJ IDEA**와 **Cursor IDE**(VSCode 기반) 모두를 지원합니다.

### `.editorconfig` - 공통 설정

두 IDE 모두 `.editorconfig`를 자동으로 인식하고 적용합니다.

#### 주요 설정 (양쪽 IDE 공통)

- **들여쓰기**: 2 spaces
- **연속 들여쓰기**: 4 spaces  
- **최대 줄 길이**: 156자
- **인코딩**: UTF-8
- **개행 문자**: LF
- **파일 끝 새줄**: 추가

### IntelliJ IDEA 설정

#### 확인 방법

1. `File > Settings > Editor > Code Style` (Mac: `Preferences`)
2. `Enable EditorConfig support` 체크박스 확인 (기본 활성화)

#### IntelliJ 전용 설정 (`ij_` 접두사)

`.editorconfig`의 `ij_`로 시작하는 설정은 **IntelliJ만 인식**:

- `ij_java_method_call_chain_wrap = normal` - 메서드 체이닝
- `ij_java_binary_operation_sign_on_next_line = true` - `.`이 새 줄 시작
- `ij_java_if_brace_force = always` - if문 중괄호 필수
- `ij_java_use_single_class_imports = true` - 와일드카드 import 금지

#### 포맷팅

- **수동**: `Cmd + Option + L` (Mac) / `Ctrl + Alt + L` (Windows)
- **자동**: `Settings > Tools > Actions on Save` → `Reformat code` 선택

### Cursor IDE / VSCode 설정

#### 필수 확장 프로그램

```bash
# Cursor IDE에서 실행
code --install-extension redhat.java
code --install-extension vscjava.vscode-java-pack
code --install-extension shengchen.vscode-checkstyle
```

또는 Cursor IDE 확장 마켓플레이스에서 설치:
- **Language Support for Java** (Red Hat)
- **Extension Pack for Java** (Microsoft)
- **Checkstyle for Java**

#### 설정 파일

프로젝트에는 Cursor용 설정이 포함되어 있습니다:

- `.vscode/settings.json` - Cursor IDE 기본 설정
- `.vscode/java-formatter.xml` - Java 포맷터 설정 (Google Style 기반)

#### 포맷팅

- **수동**: `Shift + Option + F` (Mac) / `Shift + Alt + F` (Windows)
- **자동**: `.vscode/settings.json`에서 `"editor.formatOnSave": true` 이미 설정됨

### 메서드 체이닝 결과 (양쪽 IDE 동일)

```java
// ✅ 자동 포맷팅 후 결과 (.이 새 줄 시작)
Category transportCategory = categories.stream()
    .filter(c -> "교통비".equals(c.getName()))
    .findFirst()
    .orElse(null);
```

### 설정 파일 우선순위

1. `.editorconfig` - 양쪽 IDE 공통 설정 (최우선)
2. **IntelliJ**: `ij_` 접두사 설정 (추가 세부 설정)
3. **Cursor**: `.vscode/settings.json` + `.vscode/java-formatter.xml`

### 트러블슈팅

#### IntelliJ에서 포맷팅이 적용되지 않을 때

1. `.editorconfig` 지원 확인
2. `Invalidate Caches` → `Invalidate and Restart`

#### Cursor에서 포맷팅이 적용되지 않을 때

1. Java 확장 프로그램 설치 확인
2. Java Language Server 재시작: `Cmd/Ctrl + Shift + P` → `Java: Clean Language Server Workspace`
